
## 섹션 8. 프록시와 연관관계 관리

### 프록시

Q. 멤버를 조회할때 팀도 함께 조회해야할까? -> 지연로딩으로 해결할 수 있는데 프록시를 알고있어야한다

em.find() 디비 통해 실제 엔티티 객체조회
em.getReference() 디비 조회는 안하는데 (가짜)객체조회
em.getReference() 시점에는 쿼리가 안날라가고 getName()등 호출했을때 쿼리가 날라감

#### 특징

- 실제 클래스 상속받음
- 그래서 실제 클래스와 겉모양이 같다
- 하이버네이트 내부적으로 만드는 것
- 프록시하는 라이브러리는 여러개
- 사용하는 입장에서는 이론상 진짜 객체인지 프록시 객체인지 구분하지않고 사용
- 프록시객체는 target에 참조를 보관하고 참조를 통해 getName()등을 실행

#### 특징 2

- 프록시 객체는 처음사용할때 한번만 초기화, 그 이후에 getReference하는거 그래서 똑같음
- 프록시 객체 초기화할때 프록시 객체가 실제엔티티로바뀌는것이 아니고 프록시객체를 통해서 객체접근이 가능한 것
- 프록시 객체는 원본 엔티티를 상속받음 == 비교대신 instance of 사용
- 영속성 컨텍스트에 찾은 엔티티가 이미 있다면 em.getReference()를 호출해도 실제 엔티티반환

[이미지2]
![2022-05-21_11-19-58](https://user-images.githubusercontent.com/59721293/169631337-30cb34f9-eee4-44b3-ba33-e8402fb270ae.jpg)

1. 이미 1차캐시에 있는데 프록시객체를 가져오면 이점이 없으니까
2. 같은 영속성컨텍스트이면 항상 똑같이 가져와야한다

[이미지3]
![2022-05-21_11-24-44](https://user-images.githubusercontent.com/59721293/169631347-e1ac9578-22dd-47b1-a806-26cb68d445be.jpg)

refMember 와 findMember는 당연히 다를것이다
하지만 JPA에서는 항상 똑같이 가져와야한다
그래서 findMEmber도 프록시를 가져오는것을 확인할수있다

[이미지4]
![2022-05-21_11-26-14](https://user-images.githubusercontent.com/59721293/169631371-57f0a50d-f971-4237-a333-0c3a24282ea9.jpg)


- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일때 프록시초기화하면 문제 발생
detach나 clear등 하면 영속성관리가 안되기때문이다

#### 결론

[이미지1]
![2022-05-21_11-11-08](https://user-images.githubusercontent.com/59721293/169631395-a2935d2d-10e5-4634-9d9f-7607a11ef3b0.jpg)

왜 굳이 이렇게 하는거?

사실 실무에서 getReference를 쓸일은 없는데 즉시로딩과 지연로딩 이해를 위해 중요하다

### 즉시 로딩과 지연 로딩

항상 멤버조회할때 팀도 함께 조회?
그래서 JPA에서는 지연로딩을 제공한다
Member클래스에서 팀제외하고 멤버만 조회한다
```java
Member m = em.find(Member.class, member1.getId());
System.out.println("m = " + m.getTeam().getClass());
```
```
m = class.hellojpa.Team$HibernateProxy$abcdefg
```
멤버만 조회하고 팀을 프록시로 들고온다

그다음에 m.getTeam().getName() 하면 쿼리가 나간다

EAGER로 가져올때 JOIN으로 가져와도 되고 SELECT 2개 날릴수도있는데 웬만한 JPA구현체는 JOJN으로 가져온다
(PK로 하나 찝어서 가져올때)


#### 실무에서 즉시로딩 사용하지마라

- 가급적 지연로딩만 사용

- 즉시 로딩을 적용하면 예상치못한 SQL 발생

조인이 많으면 항상 테이블있는대로 다 들고오니까

실무에서는 모두 지연로딩을 사용해라

- 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다

즉시로딩이란말은 가져올떄 팀이 무조건 값이 있어야한다
그래서 멤버가 10개면 그 10개에 해당하는 만큼 팀을 가져오기위한
별도의 쿼리(WHERE절)이 나간다

그래서 전부 지연로딩으로 했을때 팀이 필요할때 한번에 가져올수잇는 방법 3가지가 있느데,

1. JPQL에서 FETCH JOIN을 사용하면 N + 1 이 아니라 JOIN을 사용해서 팀을 가져온다
2. 엔티티그래프
3. 배치사이즈

- @ManyToOne, @OneToOne은 기본이 즉시로딩 -> LAZY로 설정

- @OneToMany, @ManyToOne은 기본이 지연로딩


### 영속성 전이(CASCADE)와 고아 객체
### 실전 예제 5 - 연관관계 관리

## 섹션 9. 값 타입

### 기본값 타입
### 임베디드 타입
### 값 타입과 불변 객체
### 값 타입의 비교
### 값 타입 컬렉션
### 실전 예제 6 - 값 타입 매핑
