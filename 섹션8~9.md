
## 섹션 8. 프록시와 연관관계 관리

### 프록시

Q. 멤버를 조회할때 팀도 함께 조회해야할까? -> 지연로딩으로 해결할 수 있는데 프록시를 알고있어야한다

em.find() 디비 통해 실제 엔티티 객체조회
em.getReference() 디비 조회는 안하는데 (가짜)객체조회
em.getReference() 시점에는 쿼리가 안날라가고 getName()등 호출했을때 쿼리가 날라감

#### 특징

- 실제 클래스 상속받음
- 그래서 실제 클래스와 겉모양이 같다
- 하이버네이트 내부적으로 만드는 것
- 프록시하는 라이브러리는 여러개
- 사용하는 입장에서는 이론상 진짜 객체인지 프록시 객체인지 구분하지않고 사용
- 프록시객체는 target에 참조를 보관하고 참조를 통해 getName()등을 실행

#### 특징 2

- 프록시 객체는 처음사용할때 한번만 초기화, 그 이후에 getReference하는거 그래서 똑같음
- 프록시 객체 초기화할때 프록시 객체가 실제엔티티로바뀌는것이 아니고 프록시객체를 통해서 객체접근이 가능한 것
- 프록시 객체는 원본 엔티티를 상속받음 == 비교대신 instance of 사용
- 영속성 컨텍스트에 찾은 엔티티가 이미 있다면 em.getReference()를 호출해도 실제 엔티티반환

[이미지2]
![2022-05-21_11-19-58](https://user-images.githubusercontent.com/59721293/169631337-30cb34f9-eee4-44b3-ba33-e8402fb270ae.jpg)

1. 이미 1차캐시에 있는데 프록시객체를 가져오면 이점이 없으니까
2. 같은 영속성컨텍스트이면 항상 똑같이 가져와야한다

[이미지3]
![2022-05-21_11-24-44](https://user-images.githubusercontent.com/59721293/169631347-e1ac9578-22dd-47b1-a806-26cb68d445be.jpg)

refMember 와 findMember는 당연히 다를것이다
하지만 JPA에서는 항상 똑같이 가져와야한다
그래서 findMEmber도 프록시를 가져오는것을 확인할수있다

[이미지4]
![2022-05-21_11-26-14](https://user-images.githubusercontent.com/59721293/169631371-57f0a50d-f971-4237-a333-0c3a24282ea9.jpg)


- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일때 프록시초기화하면 문제 발생
detach나 clear등 하면 영속성관리가 안되기때문이다

#### 결론

[이미지1]
![2022-05-21_11-11-08](https://user-images.githubusercontent.com/59721293/169631395-a2935d2d-10e5-4634-9d9f-7607a11ef3b0.jpg)

왜 굳이 이렇게 하는거?

사실 실무에서 getReference를 쓸일은 없는데 즉시로딩과 지연로딩 이해를 위해 중요하다

### 즉시 로딩과 지연 로딩
### 영속성 전이(CASCADE)와 고아 객체
### 실전 예제 5 - 연관관계 관리

## 섹션 9. 값 타입

### 기본값 타입
### 임베디드 타입
### 값 타입과 불변 객체
### 값 타입의 비교
### 값 타입 컬렉션
### 실전 예제 6 - 값 타입 매핑
