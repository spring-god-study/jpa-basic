# 객체지향 쿼리 언어1 - 기본 문법

## 소개

JPA는 다양한 쿼리 방법을 지원 - 복잡한 쿼리

- JPQL
- JPA Criteria
- QueryDSL (자바 코드를 짜서)
- 네이티브 SQL (디비 종속적인 쿼리 - 오라클 connet by (표준 문법을 벗어나는))
- JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용

하이버네이트 만든 갤빈 킹도 말함 - 100%의 문제를 해결하려고 만든것이아니다

대부분 문제는 JPQL로 해결이되는데 이럴때 다른 걸 같이 사용

### JPQL 소개

단순한 조회방법은
- EntityManager.find();
- 객체 그래프 탐색

그런테 나이가 18살 이상인 member를 조회한다면?

- JPA를 사용하면 엔티티 객체 중심 개발
- 문제는 검색 쿼리
- 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
- 모든 디비데이터를 객체로 변환해서 검색하는 것은 불가능
- **앱에서 필요한 데이터만 DB에서 불러오려면 결국 검색조건이 포함된 SQL이 필요**

그래서 JPQL이 나옴

- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
- SQL 문법과 유사, ANSI표준에서 지원하는건 다 지원함
- JPQL은 엔티티 객체를 대상으로 쿼리, SQL은 디비테이블을 대상으로 쿼리

#### 예시

```java
em.createQuery("select m from Member m where m.username like '%kim%'", Member.class).getResultList();

for (Member member : result) {
	log.info(member);
}
```
```
JPQL -> SQL 로 전환되는걸 확인 가능
```

### Criteria 소개

- JPQL이 단순 String이기 때문에 동적쿼리를 하기가 굉장히 힘들다
- JPQL 빌더역할

#### 예제
```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

Root<Member> m = query.form(Member.class);

query.select(m).where(cb.equals(m.get("username"), "kim"))

em.createQuery(cq).getResultList();
```

근데 너무 복잡하다.
하지만 자바코드로 짜니까 오타를 내면 바로 컴파일에러가 나고 동적쿼리를 사용하기가 편하다
그런데 가독성이 떨어져서 안쓴다 (망한스펙)

### QueryDSL

```java
QMember m = QMember.member;
List<Member> result = queryFactory
		.select(m)
		.from(m)
		.where(m.name.like("kim"))
		.fetch();
```

너무 깔끔하다.
그리고 m.name도 컴파일체크한다
메소드 형식으로 재사용 가능하다

중요한건 JPQL을 잘알고있으면 QueryDSL 도뮤먼트 보고 따라하면 되므로 JPQL을 잘알고있음된다

### 네이티브 SQL

- JPA가 제공하는 SQL 직접 사용
- 디비 의존적인 쿼리사용할때

### JDBC 직접사용, SpringJdbcTemplate 등

- JPA를 사용하면서 JDBC 커넥션 직접사용하거나 스프링 JdbcTemplate, MyBatis등을 함께 사용가능
- 단 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요

주의사항:
```java
Member member = new Member();
member.setUsername("member1");
em.persist(member);

// flush -> commit, query 날라감

List<Member> resultList = em.createNativeQuery("...").getResultList();

//네이티브 SQL같은 JPA관련기술을 쓰면 자동으로 flush되기때문에 member가 디비에 영속화되고 createNativeQuery를 사용하는데 문제가없다

for (Member member1 : resultList) {
	log.info(member1);
}
```
문제는 JPA 관련된게 아니라
```java
dbconn.executeQuery("select * from member");
```
JPA와 관련이 없기때문에 데이터 result가 0이다

그렇기 때문에 적절한 시점에 강제로 flush 해줘야한다


## 기본 문법과 쿼리 API

### JPQL
- 엔티티대상으로 쿼리
- 특정디비 SQL 에 의존히자읺는다. JPQL은 SQL 추상화

#### 문법

- select m from Member as m where m.age > 18
- 대소문자 구분
- JPQL 키워드는 대소문자 구분 X (WHERE, where)
- 엔티티이름사용, 테이블 이름이 아님 (Member)
- 별칭은 필수 as는 생략가능

#### TypeQuery, Query

- TypeQuery: 반환타입 명확할때 사용
- Query: 명확하지않을때 사용

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);
Query query = em.createQuery("SELECT m.username, m.age FROM Member m");
```

#### 결과 조회 API

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);
Member result = query.getResultList(); // 결과가없으면 빈리스트 반환 (NPE 걱정 X)
Member result = query.getSingleResult(); // 결과가 정확히 하낭, 단일 객체 반환, 결과없을떄 결과2개이상일때  exception 발생
```
Spring Data JPA 에서는 결과가 없으면 null 아니면 optional 반환 

#### 파라미터 바인딩

이름기준
```java
TypedQuery<Member> query = em.createQuery("select m from Member m where m.username = :username", Member.class);
query.setParameter("username", "member1");
Member m = query.getSingleResult();
```

위치기준
```java
TypedQuery<Member> query = em.createQuery("select m from Member m where m.username = ?1", Member.class);
query.setParameter(1, "member1");
Member m = query.getSingleResult();
```

## 프로젝션(SELECT)

프로젝션

- SELECT 절에 조회할 대상을 지정하는 것
- 프로젝션 대상: 엔티티, 임베디드타입, 스칼라 타입(숫자,문자등 기본데이터 타입)
- SELECT m FROM Member m -> 엔티티 프로젝션
- SELECT m.team FROM Member m -> 엔티티 프로젝션
- SELECT m.addreess FROM Member m -> 임베디드 타입 프로젝션
- SELECT m.username, m.age FROM Member m -> 스칼라타입
- DISTINCT로 중복제거

```java
/* ... Member 생성해서 flush,clear 하는 코드 ... */

List<Member> result = ...;

Member findMember = result.get(0);
findMember.setAge(20);

tx.commit();
```
-> 영속성컨텍스트에서 관리하므로 update쿼리나간거 확인가능

```java
/* ... Member 생성해서 flush,clear 하는 코드 ... */

List<Team> result = em.createQuery("select m.team from Member m", Team.class).getResultList();

tx.commit();
```
-> join해서 team가져오는거 확인 가능
-> "select t from Member m join m.team t" 으로 변경해야함, 예측이 안되기때문에 명시해줘야함 (운영하면서 쿼리튜닝하는데) // 명시적 조인, 묵시적조인

```java
/* ... Member 생성해서 flush,clear 하는 코드 ... */

em.createQuery("select o.address from Order o", Address.class).getResultList();

tx.commit();
```
-> 임베디드타입이라 괜찮

```java
/* ... Member 생성해서 flush,clear 하는 코드 ... */

result = em.createQuery("select m.username, m.age from Member m", Member.class).getResultList();

tx.commit();
```
-> 스칼라타입

### 프로젝션 - 여러 값 조회

- SELECT m.username, m.age FROM Member m
- Object로 가져와야함

```java
List resultList = em.createQuerY("SELECT m.username, m.age FROM Member m").getResultList();

Object o = resultList.get(0);
Object[] result = (Object[]) o;

String username = result[0];
String age = result[1];
```

```java
List<Object[]> resultList = em.createQuerY("SELECT m.username, m.age FROM Member m").getResultList();

Object[] result = resultList.get(0);

String username = result[0];
String age = result[1];
```

- **new**

```java
em.createQuery("select new package.MemberDTO(m.username, m.age) from Member m", MemberDTO.class).getResultList(); // 생성자는 미리 만들어주고

MemberDTO memberDTO = result.get(0);
```

## 페이징

## 조인

## 서브 쿼리

## JPQL 타입 표현과 기타식

## 조건식 (CASE 등등)

## JPQL 함수
