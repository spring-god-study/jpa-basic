
## 섹션 0. 강좌 소개

### 강좌 소개
  - JDBC, MyBatis/JdbcTemplate, JPA 농기계 비교 (자동화)
  - JPA가 실무에서 어려운 이유
    - 객체와 테이블을 올바르게 매핑하는 설계하는 방법을 몰라서 사람들이 삽질을 많이한다
    - 실무는 수십개이상의 복잡한 객체와 테이블을 사용한다
      - 제대로 가르쳐주는 곳이없다
    - JPA의 내부 동작 방식을 제대로 이해해야
      - JPA가 어떤 SQL을 만들어 내는지
      - JPA가 언제 SQL을 실행하는지

### 목표:   
> - 객체와 테이블을 제대로 설계하고 매핑하는 방법   
> - 기본 키와 외래 키 매핑   
> - 1:N, N:1, 1:1, N:M 매핑   
> - 실무 노하우 + 성능 고려   
> - 어떠한 복잡한 시스템도 JPA로 설계 가능   

### 수업 자료

## 섹션 1. JPA 소개

### SQL 중심적인 개발의 문제점
  - 무한 반복, 지루한 코드
  - 자바 객체를 SQL로...SQL을 자바 객체로..
    - 필드 추가시 모든 쿼리에 추가 
  - 패러다임의 불일치
    - 관계형은 데이터를 잘 정리해서 저장하는게 목적
    - OOP
  - 객체를 계속 SQL변환 -> 개발자 equals SQL 매퍼

###  객체와 관계형 데이터베이스의 차이
  - 상속 -> 비슷한게 있긴한데, RDB는 없다
  - 연관관계 -> RDB는 PK,FK 조인을해서 찾는다
  - 데이터타입
  - 데이터식별방법

#### 상속
![2022-04-26_22-43-55](https://user-images.githubusercontent.com/59721293/165313788-41c00771-162c-4a21-851c-ca3896f1ae6e.jpg)
- Album을 조회할때, ITEM에 ALBUM을 JOIN해서 가져와야한다
- Movie, Book.. 다 똑같이 Join해서 가져오니까 복잡해짐
- 그런데 자바 컬렉션에서 조회하면?
  - Album album = list.get(albumId);
  - 또는 Item item = list.get(albumId);

#### 연관관계
![2022-04-26_22-49-35](https://user-images.githubusercontent.com/59721293/165314957-10859b30-540c-425b-b7d8-985b91fcffd2.jpg)
- 객체는 한방향으로 조회가능
- 테이블은 양방향으로 조회가능
- 보통 객체를 테이블에 맞춘다
- 객체다운 모델링?
```java
class Member {
  String id;
  String name;
  Team team;
}

class Team {
  String id;
  String name;
}
``` 
![2022-04-26_22-53-43](https://user-images.githubusercontent.com/59721293/165315751-66484391-c87d-4113-bb68-f1a4fe9b081c.jpg)
- 객체 모델링 조회
  - 자바 컬렉션에 관리하면 쉽게 된다
    - list.add(member); Member member = list.get(memberId); Team team = member.getTeam();
- 객체 그래프 탐색
  - 쩜찍어서 가는거
  - SQL로 불러오면
    - Member member = memberDao.find(memberId); -> member.getTeam()이나 member.getOrder()가 값이 있다고 확신할수있나? ㄴㄴ
    - 엔티티 신뢰에 문제가 생김
      - 왜?
      - memberDao.find에서 무슨 쿼리가 실행됐는지 어떻게 눈으로 확인하지 않는이상은 모른다
      - 그렇다고 모든 객체를 미리 로딩할순없다
      - ![2022-04-26_23-01-54](https://user-images.githubusercontent.com/59721293/165317406-daa8cb10-e3e6-4087-bf95-3a1b92ebf165.jpg)

그래서 계층 분할이 어렵다.

- 비교하기
  - dao에서 꺼내온 getMember(memberId)의 Member 두개는 결과가 다르다
  - 내부적으로 getMember할때 return new Member() 할거기때문
  - 자바 컬렉션에서 조회한다면?
    - list.get(memberId); 를 부른 Member1과 Member2는 같다 참조이기때문에


> 결론: 객체답게 모델링 하려면 할수록 번잡한 작업만 늘어난다 그래서 SQL에 맞춰서 개발할 수 밖에 없다
> 
> **객체를 자바 컬렉션에 저장하듯이 DB에 저장할 수는 없을까?** -> JPA!


## JPA 소개
  - Java Persistence API
  - 자바 진영의 ORM 기술 표준

### ORM?
  - 객체관계스럽게, 관계형 데이터베이스 스럽게, 중간의 차이점을 ORM이 매꾼다.

### JPA는 어플리케이션과 JDBC 사이에서 동작한다
  -  JPA에게 명령하면 JDBC API를 호출해서 DB와 동작한다
  - 저장?
    - JPA에게 객체를 넘기면 JPA에서 알아서 SQL 만들어서 JDBC API에게 넘겨서 결과 반환받음
  - 조회?
    - 똑같이 JPA가 알아서 SQL을 만들고 JDBC API에게 넘겨서 결과 반환받음
  - 패러다임의 불일치 해결

###  JPA 역사
  - EJB (옛날 ORM)
    - 문제: 넘 느림, 기능도 잘 안작동함
  - 하이버네이트 나옴 (오픈소스)
  - 하이버네이트 거의 복붙 -> JPA
  - JPA는 표준 명세
    - JPA는 인터페이스의 모음
    - JPA2.1 표준 명세를 구현한 3가지 구현체가 있는데 거의 하이버네이트

### JPA를 왜 사용해야하는가?
  - SQL 중심 -> 객체 중심
  - 생산성: CRUD 그냥 메소드 불러서 쓰면 됨
    - 특히 수정이 굿, 객체에 setter쓰면 바로 업데이트 됨
  - JPA와 연관관계, 객체 그래프 탐색 가능해짐
    - 아까 SQL 직접 짰던건 엔티티 신뢰가 안된다
    - 그런데 JPA에서는 member.getTeam(); member.getOrder(); 등등 지연로딩이라는 기능 덕분에 부르는 시점에 SQL실행해서 결과를 받을수있음
    - 즉 JPA에서는 엔티티를 신뢰할수있다
  - JPA로 비교하기 -> == -> 같다 
    - 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장
  - JPA 성능 최적화 기능
    - 1차 캐시, 동일성(identity) 보장
      -  동일한 트랜잭션에서 조회한 엔티티는 같음을 보장
        - 약간의 조회 성능 향상
      - 어플리케이션층에서 Repetable Read 보장
        - 한 트랜잭션 내에서는 똑같은 결과를 조회한다
      - 짧은 시간의 캐싱
  - 트랜잭션 지원 쓰기 지연
    - 커밋할때까지 INSERT SQL 모음
    
### 지연 로딩과 즉시로딩


### 섹션 2. JPA 시작하기

- Hello JPA - 프로젝트 생성
- Hello JPA - 애플리케이션 개발

### 섹션 3. 영속성 관리 - 내부 동작 방식

- 영속성 컨텍스트 1
- 영속성 컨텍스트 2
- 플러시
- 준영속 상태
- 정리
